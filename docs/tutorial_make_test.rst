Tutorial 8: Generating tests programmatically
=============================================

You can use ReFrame to generate tests programmatically using the special :func:`~reframe.core.meta.make_test` function.
This function creates a new test type as if you have typed it manually using the :keyword:`class` keyword.
You can create arbitrarily complex tests that use variables, parameters, fixtures and pipeline hooks.

In this tutorial, we will use :func:`~reframe.core.meta.make_test` to build a simple domain-specific syntax for generating variants of STREAM benchmarks.
Our baseline STREAM test is the following:

.. literalinclude:: ../tutorials/advanced/make_test/stream.py

It is essentially the STREAM benchmark split in two tests: one that builds the binaries based on set of variables and another one that runs it.

For our example, we would like to create a simpler syntax for generating multiple different :class:`stream_test` versions that could run all at once.
Here is an example specification file for those tests:

.. literalinclude:: ../tutorials/advanced/make_test/stream_config.yaml

The :attr:`thread_scaling` configuration parameter for the last workflow will create a parameterised version of the test using different number of threads.
In total, we expect six :class:`stream_test` versions to be generated by this configuration.

The process for generating the actual tests from this spec file comprises three steps and everything happens in a somewhat unconventional, though valid, ReFrame test file:

1. We load the test configuration from a spec file that is passed through the ``STREAM_SPEC_FILE`` environment variable.
2. Based on the loaded test specs we generate the actual tests using the :func:`~reframe.core.meta.make_test` function.
3. We register the generated tests with the framework by applying manually the :func:`@simple_test <reframe.core.decorators.simple_test>` decorator.

The whole code for generating the tests is the following and is only a few lines.
Let's walk through it.

.. literalinclude:: ../tutorials/advanced/make_test/stream_workflows.py

The :func:`load_specs()` function simply loads the test specs from the YAML test spec file and does some simple sanity checking.

The :func:`generate_tests()` function consumes the test specs and generates a test for each entry.
Each test inherits from the base :class:`stream_test` and redefines its :attr:`stream_binaries` fixture so that it is instantiated with the set of variables specified in the test spec.
Remember that all the STREAM test variables in the YAML file refer to its build phase and thus its build fixture.
We also treat specially the :attr:`thread_scaling` spec parameter.
In this case, we add a :attr:`num_threads` parameter to the test and add a post-init hook that sets the test's :attr:`~reframe.core.pipeline.RegressionTest.num_cpus_per_task`.

Finally, we register the generated tests using the :func:`rfm.simple_test` decorator directly;
remember that :func:`~reframe.core.meta.make_test` returns a class.

The equivalent of our test generation for the third spec is exactly the following:

.. code-block:: python

   @rfm.simple_test
   class stream_test_2(stream_test):
       stream_binaries = fixture(stream_build, scope='environment',
                                 variables={'elem_type': 'double',
                                            'array_size': 16777216,
                                            'num_iters': 10})
       num_threads = parameter([1, 2, 4, 8])

       @run_after('init')
       def _set_num_threads(self):
           self.num_cpus_per_task = self.num_threads

And here is the listing of generated tests:

.. code-block:: bash

   STREAM_SPEC_FILE=stream_config.yaml ./bin/reframe -C tutorials/cscs-webinar-2022/config/mysettings.py -c tutorials/advanced/make_test/stream_workflows.py -l

.. code-block:: console

   [List of matched checks]
   - stream_test_2 %num_threads=8 %stream_binaries.elem_type=double %stream_binaries.array_size=16777216 %stream_binaries.num_iters=10 /7b20a90a
       ^stream_build %elem_type=double %array_size=16777216 %num_iters=10 ~tresa:default+gnu 'stream_binaries /1dd920e5
   - stream_test_2 %num_threads=4 %stream_binaries.elem_type=double %stream_binaries.array_size=16777216 %stream_binaries.num_iters=10 /7cbd26d7
       ^stream_build %elem_type=double %array_size=16777216 %num_iters=10 ~tresa:default+gnu 'stream_binaries /1dd920e5
   - stream_test_2 %num_threads=2 %stream_binaries.elem_type=double %stream_binaries.array_size=16777216 %stream_binaries.num_iters=10 /797fb1ed
       ^stream_build %elem_type=double %array_size=16777216 %num_iters=10 ~tresa:default+gnu 'stream_binaries /1dd920e5
   - stream_test_2 %num_threads=1 %stream_binaries.elem_type=double %stream_binaries.array_size=16777216 %stream_binaries.num_iters=10 /7a7dcd20
       ^stream_build %elem_type=double %array_size=16777216 %num_iters=10 ~tresa:default+gnu 'stream_binaries /1dd920e5
   - stream_test_1 %stream_binaries.elem_type=double %stream_binaries.array_size=1048576 %stream_binaries.num_iters=100 %stream_binaries.num_cpus_per_task=1 /3e3643dd
       ^stream_build %elem_type=double %array_size=1048576 %num_iters=100 %num_cpus_per_task=1 ~tresa:default+gnu 'stream_binaries /3611a49a
   - stream_test_0 %stream_binaries.elem_type=float %stream_binaries.array_size=16777216 %stream_binaries.num_iters=10 %stream_binaries.num_cpus_per_task=4 /d99b89f1
       ^stream_build %elem_type=float %array_size=16777216 %num_iters=10 %num_cpus_per_task=4 ~tresa:default+gnu 'stream_binaries /321abb06
   Found 6 check(s)


.. note::

   The path passed to ``STREAM_SPEC_FILE`` is relative to the test directory.
   Since version 4.2, ReFrame changes to the test directory before loading a test fil.
   In prior versions you have to specify the path relative to the current working directory.
